1. Was versteht man unter einem Programmierparadigma?  
2. Wozu dient ein Berechnungsmodell?  
3. Welche Berechnungsmodelle werden in Programmierparadigmen verwendet, und welche charakteristischen Eigenschaften haben sie?  
4. Welche Eigenschaften von Berechnungsmodellen sind für deren Erfolg häufig (mit)bestimmend?  
5. Im Spannungsfeld welcher widersprüchlichen Ziele befinden sich Programmierparadigmen? Wie äußert sich dieses Spannungsfeld?  
6. Was ist die strukturierte Programmierung? Wozu dient sie?  
7. Wie gehen unterschiedliche Paradigmen mit Seiteneffekten um?  
8. Was bedeutet referentielle Transparenz, und wo findet man referentielle Transparenz?  
9. Wieso passt referentielle Transparenz nicht gut mit Ein- und Ausgabe zusammen, und wie kann man das Dilemma lösen?  
10. Welchen Zusammenhang gibt es zwischen Seiteneffekten und der objektorientierten Programmierung?  
11. Was sind First-Class-Entities? Welche Gründe sprechen für deren Verwendung, welche dagegen?  
12. Was haben Funktionen höherer Ordnung mit einem applikativen Programmierstil zu tun?  
13. Welche Modularisierungseinheiten gibt es, was sind ihre charakteristischen Eigenschaften, und wodurch unterscheiden sie sich?  
14. Welche Bedeutung haben Schnittstellen für Modularisierungseinheiten? Warum unterscheidet man zwischen von außen zugreifbaren und privaten Inhalten?  
15. Was ist und wozu dient ein Namensraum?  
16. Warum können Module nicht zyklisch voneinander abhängen, Komponenten aber schon?  
17. Was versteht man unter Datenabstraktion, Kapselung und Data-Hiding?  
18. Warum und inwiefern ist die Einbindung von Komponenten komplizierter als die von Modulen?  
19. Wie kann man globale Namen verwalten?  
20. Was versteht man unter Parametrisierung? Wann kann das Befüllen von „Lücken“ durch welche Techniken erfolgen?  
21. Warum braucht man zur Parametrisierung in der Objekterzeugung neben Konstruktoren gelegentlich auch Initialisierungsmethoden?  
22. Welche Vor- und Nachteile hat die zentrale Ablage von Werten zum Zweck der Parametrisierung?  
23. Was unterscheidet Generizität von den verschiedenen Formen der Parametrisierung zur Laufzeit?  
24. Was sind Annotationen und wozu kann man sie verwenden? Wodurch unterscheiden sie sich von Generizität?  
25. Was versteht man unter aspektorientierter Programmierung?  
26. Wodurch unterscheidet sich Parametrisierung von der Ersetzbarkeit, und warum ist die Ersetzbarkeit von so zentraler Bedeutung?  
27. Wann ist A durch B ersetzbar?  
28. Wodurch kann festgelegt sein, ob A durch B ersetzbar ist?  
29. Was ist die Signatur einer Modularisierungseinheit?  
30. Wie verhält sich die Signatur einer Modularisierungseinheit zur Abstraktion, die durch diese Modularisierungseinheit gebildet wird?  
31. Was sind Zusicherungen, und welche Rolle spielen sie für Modularisierungseinheiten?  
32. Wann sind Typen miteinander konsistent, und was sind Typfehler?  
33. Wie schränken Typen die Flexibilität ein, und warum verwendet man Typen trotzdem?  
34. Welche Gründe sprechen für den Einsatz statischer Typprüfungen, welche dagegen?  
35. Was versteht man unter Typinferenz? Welche Gründe sprechen für bzw. gegen den Einsatz?  
36. Zu welchen Zeitpunkten können Entscheidungen getroffen werden (Typen und Entscheidungsprozesse)?  
37. Welchen Einfluss können Typen auf Entscheidungszeitpunkte haben?  
38. Wie beeinflussen Typen die Planbarkeit weiterer Schritte?  
39. Was ist ein abstrakter Datentyp?  
40. Was unterscheidet strukturelle von nominalen Typen?  
41. Warum verwenden wir in Programmiersprachen meist nominale Typen, in theoretischen Modellen aber hauptsächlich strukturelle?  
42. Wie hängen Untertypbeziehungen mit Ersetzbarkeit zusammen?  
43. Warum kann ein Compiler ohne Unterstützung durch Programmierer_innen nicht entscheiden, ob ein nominaler Typ Untertyp eines anderen nominalen Typs ist?  
44. Erklären Sie Einschränkungen bei Untertypbeziehungen zusammen mit statischer Typprüfung.  
45. In welchem Zusammenhang verwendet man Higher-Order-Subtyping und F-gebundene Generizität?  
46. Wie konstruiert man rekursive Datenstrukturen?  
47. Was versteht man unter Fundiertheit rekursiver Datenstrukturen? Welche Ansätze dazu kann man unterscheiden?  
48. Warum wird Typinferenz in objektorientierten Sprachen meist nur lokal beschränkt eingesetzt?  
49. Wie können statisch geprüfte Typen beliebige Eigenschaften von Werten propagieren?  
50. Erklären Sie folgende Begriffe:  
		• Objekt, Klasse, Vererbung  
		• Identität, Zustand, Verhalten, Schnittstelle  
		• deklarierter, statischer und dynamischer Typ  
		• Faktorisierung, Refaktorisierung  
	  • Verantwortlichkeiten, Klassenzusammenhalt, Objektkopplung  
51. Welche Arten von Polymorphismus unterscheidet man? Welche davon sind in der objektorientierten Programmierung wichtig? Warum?  
52. Wann sind zwei gleiche Objekte identisch und wann sind zwei identische Objekte gleich?  
53. Sind Datenabstraktion, Datenkapselung und Data-Hiding einander entsprechende Begriffe? Wenn Nein, worin unterscheiden sie sich?  
54. Was besagt das Ersetzbarkeitsprinzip? (Häufige Prüfungsfrage!)  
55. Warum ist Ersetzbarkeit in der objektorientierten Programmierung so wichtig (mehrere Gründe)?  
56. Wann und warum ist gute Wartbarkeit wichtig?  
57. Wie lauten die wichtigsten Faustregeln im Zusammenhang mit Klassenzusammenhalt und Objektkopplung? Welche Vorteile kann man sich davon erwarten, dass diese Faustregeln erfüllt sind?  
58. Von welchen Kriterien hängen Klassenzusammenhalt und Objekt-  
kopplung genau ab?  
59. Wie kann man überprüfen, wie hoch der Klassenzusammenhalt und wie stark die Objektkopplung ist?  
60. Wie wirkt sich ein hoher Klassenzusammenhalt auf die Faktorisierung und Refaktorisierbarkeit aus?  
61. Wie wirkt sich eine schwache Objektkopplung auf die Faktorisierung und Refaktorisierbarkeit aus?  
62. Welche Arten von Software kann man wiederverwenden, und welche Rolle spielt jede davon in der Softwareentwicklung?  
63. Welche Rolle spielen Refaktorisierungen in der Wiederverwendung?  
64. Wofür ist die objektorientierte Programmierung gut geeignet, und wofür ist sie nicht gut geeignet?

[[Ersetzbarkeitsprinzip|Next]]
